"""`main` is the top level module for your Flask application."""

# Import the Flask Framework
from flask import Flask
from flask import Flask, request, session, g, redirect, url_for, abort, \
    render_template, flash
import os
import cgi
import jinja2
import MySQLdb
import json
import sys
import datetime
from google.appengine.api import memcache
from random import random

# Configure the Jinja2 environment.
JINJA_ENVIRONMENT = jinja2.Environment(
    loader=jinja2.FileSystemLoader(os.path.dirname(__file__)),
    autoescape=True,
    extensions=['jinja2.ext.autoescape'])

# Define your production Cloud SQL instance information.
_INSTANCE_NAME = 'indiaelectiontracker:ls14'

app = Flask(__name__)
# Note: We don't need to call run() since our application is embedded within
# the App Engine WSGI application server.

def get_data(fnname, param):
    key = fnname + ":" + param
    data = memcache.get(key)
    if data is not None:
        return data
    else:
        data = getattr(sys.modules[__name__], fnname)(param)
        memcache.add(key, data, 60)
        return data


@app.route('/')
def hello():
    """Return a friendly HTTP greeting."""
    results = get_data('get_results', '')
    shares = get_data('get_shares', '')

    return render_template('summary.html', results=results, shares=shares)


@app.route('/json/parties')
def fetchParties():
    return get_data('listOfParties', '')


@app.route('/json/states')
def fetchStates():
    return get_data('get_state_list', '')


@app.route('/json/constituencies')
@app.route('/json/constituencies/<state_code>')
def fetchConstituencies(state_code=None):
    if state_code:
        return get_data('listOfConstituencies', state_code)
    else:
        return get_data('listOfConstituencies', '')


def listOfConstituencies(state_code):
    db = get_db()
    cursor = db.cursor()
    if not state_code:
        cursor.execute(
            'Select c.name,c.constituency_code,s.name from constituency c inner join state s on s.id = c.state_id')
    else:
        cursor.execute(
            'Select c.name,c.constituency_code,s.name from constituency c inner join state s on s.id = c.state_id where s.state_code = "' + state_code + '"')

    cList = []
    for row in cursor.fetchall():
        cList.append({"name": cgi.escape(row[0]), "state": cgi.escape(row[2]), "constituency_code": cgi.escape(row[1])})
    return json.dumps(cList)


def listOfParties(params):
    db = get_db()
    cursor = db.cursor()
    cursor.execute('SELECT name from party')
    partyList = []
    for row in cursor.fetchall():
        partyList.append({"party": cgi.escape(row[0])})
    return json.dumps(partyList)


def get_state_list(params):
    db = get_db()
    cursor = db.cursor()
    cursor.execute('SELECT name, shortform, state_code FROM state')
    statelist = []
    for row in cursor.fetchall():
        statelist.append(dict([('name', cgi.escape(row[0])),
                               ('shortform', cgi.escape(row[1])),
                               ('state_code', cgi.escape(row[2]))]))
    return json.dumps(statelist)


def get_results(params):
    db = get_db()
    cursor = db.cursor()
    cursor.execute("""SELECT c.shortform , SUM(twotab.seats) seatsc from 
        (SELECT  l.party_id,count(*) seats from `last_time_results` l inner join 
        (select constituency_id, party_id, max(votes) votes from last_time_results 
        group by constituency_id) maxtab on l.constituency_id=maxtab.constituency_id 
        and l.votes=maxtab.votes group by l.party_id) twotab, party p, coalition c 
        where twotab.party_id=p.id and p.coalition_id =c.id group by c.shortform 
        order by seatsc desc""")
    results = []
    for row in cursor.fetchall():
        results.append({"coalition": cgi.escape(row[0]), "result": "Wins", "seats": float(row[1])})

    """Example: results.append({ "coalition":"BJP+", "result":"Wins", "seats":200 })
    results.append({ "coalition":"BJP+", "result":"Leads", "seats":20 })
    """
    return json.dumps(results)


def get_shares(params):
    shares = []
    db = get_db()
    cursor = db.cursor()
    cursor.execute("""SELECT c.name, SUM(l.votes)/100000 FROM `last_time_results` l, 
        party p, coalition c WHERE c.id=p.coalition_id and 
        p.id=l.party_id group by c.id""")

    for row in cursor.fetchall():
        shares.append({"coalition": cgi.escape(row[0]), "share": float(row[1])})
    return shares


@app.errorhandler(404)
def page_not_found(e):
    """Return a custom 404 error."""
    return 'Sorry, Nothing at this URL.', 404


@app.errorhandler(500)
def page_not_found(e):
    """Return a custom 500 error."""
    return 'Sorry, unexpected error: {}'.format(e), 500


@app.route('/partyWiseResult/<partyId>')
def partyWiseResults(partyId):
    db = get_db()
    cursor = db.cursor()
    cursor1 = db.cursor()
    cursor.execute(
        """select rs.constituency_id,cs.name as constituency,rs.candidate_id,c.fullname as candidate_name,(votes - max_votes) as lead,p.name as winning_party,MY.candidate_id,wc.fullname,rs.status,MY.max_votes as max_votes from results rs inner join candidate c on c.id = rs.candidate_id inner join constituency cs on cs.id = rs.constituency_id inner join (SELECT rs1.constituency_id,rs1.candidate_id,rs1.party_id as winning_party_id,rs1.votes as max_votes FROM resultdayanalysis.results rs1 left join results rs2 on rs1.constituency_id = rs2.constituency_id and rs1.votes < rs2.votes where rs2.constituency_id is null ) as MY on MY.constituency_id = rs.constituency_id inner join party p on p.id = MY.winning_party_id inner join candidate wc on wc.id = MY.candidate_id where rs.active = true and rs.party_id = %s;""",
        (partyId))

    results = []
    for row in cursor.fetchall():
        if row[4] < 0:
            results.append({"constituency_id": row[0], "constituency_name": row[1], "candidate_id": row[2],
                            "candidate_name": row[3], "lead": row[4], "competing_party": row[5],
                            "competing_candidate_id": row[6], "competing_candidate_name": row[7],
                            "competing_votes": row[9], "status": row[8]})

        else:
            cursor1.execute(
                "SELECT c.id,c.fullname,votes,p.id,p.name from results rs inner join candidate c on c.id = rs.candidate_id inner join party p on p.id = rs.party_id where constituency_id = %s and active = true order by votes desc",
                (row[0]))
            i = 0
            for r in cursor1.fetchall():
                if i == 1:
                    lead = row[9] - r[2]
                    results.append({"constituency_id": row[0], "constituency_name": row[1], "candidate_id": row[2],
                                    "candidate_name": row[3], "lead": lead, "competing_party": r[1],
                                    "competing_candidate_id": r[3], "competing_candidate_name": r[4],
                                    "competing_votes": row[2], "status": row[8]})
                    break
                else:
                    pass
                i += 1

    return json.dumps(results)


#@app.route('/fillRandomResults')
def fill_random_results():
    db = get_db()
    cursor = db.cursor()
    cursor.execute('SELECT * from last_time_results')

    results = []
    importDate = datetime.date(2014, 4, 15)
    for row in cursor.fetchall():
        number = random()
        status = "DECLARED"
        if number > 0.5:
            status = "COUNTING"
        else:
            pass
        results.append({"candidate_id": row[0], "constituency_id": row[1], "votes": row[2], "party_id": row[3],
                        "time_start": str(importDate), "status": status})

    for res in results:
        cursor.execute('''Insert into results (constituency_id,candidate_id,party_id,votes,active,time_start,status) values
				(%s,%s,%s,%s,true,%s,"%s")''', (
            res['constituency_id'], res['candidate_id'], res['party_id'], res['votes'], res['time_start'], res['status']))

    db.commit()
    return json.dumps(results)


def connect_db():
    """Connects to the specific database."""
    if (os.getenv('SERVER_SOFTWARE') and
            os.getenv('SERVER_SOFTWARE').startswith('Google App Engine/')):
        db = MySQLdb.connect(unix_socket='/cloudsql/' + _INSTANCE_NAME, db='resultdayanalysis', user='ls14',
                             passwd='kejriwal')
    else:
        db = MySQLdb.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='resultdayanalysis')
        # Alternately, connect to a Google Cloud SQL instance using:
        # db = MySQLdb.connect(host='ip-address-of-google-cloud-sql-instance', port=3306, user='root')
    return db


def get_db():
    """Opens a new database connection if there is none yet for the
    current application context.
    """
    if not hasattr(g, 'mysql_db'):
        g.mysql_db = connect_db()
    return g.mysql_db


@app.teardown_appcontext
def close_db(error):
    """Closes the database again at the end of the request."""
    if hasattr(g, 'mysql_db'):
        g.mysql_db.close()

#if __name__ == '__main__':
#	app.run(debug=True)
